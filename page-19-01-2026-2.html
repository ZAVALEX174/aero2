<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–†–µ–¥–∞–∫—Ç–æ—Ä —á–µ—Ä—Ç–µ–∂–µ–π —Å —Ä–µ–¥–∞–∫—Ç–æ—Ä–æ–º —Å–≤–æ–π—Å—Ç–≤ (Fabric.js)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0 5px 5px 5px;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }

    .container {
      background: white;
      border-radius: 15px;
      padding: 0;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 10px;
      font-size: 32px;
      font-weight: 700;
    }

    .subtitle {
      color: #7f8c8d;
      text-align: center;
      margin-bottom: 30px;
      font-size: 16px;
    }

    .main-content {
      display: flex;
      gap: 25px;
      margin-top: 20px;
    }

    .left-panel {
      flex: 1;
      max-width: 300px;
    }

    .canvas-container {
      min-height: 600px;
    }

    #canvas-container {
      border: 2px solid #ddd;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      background: #fff;
    }

    #tools {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 20px;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 10px;
      border: 1px solid #e9ecef;
    }

    button {
      padding: 5px 5px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 3px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 7px 14px rgba(50, 50, 93, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08);
    }

    button:active {
      transform: translateY(0);
    }

    .active-mode {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08);
    }

    #status {
      background: #2c3e50;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      margin-top: 15px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .properties-panel {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      padding: 20px;
      margin-top: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    }

    .properties-panel h3 {
      color: #2c3e50;
      margin-top: 0;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #f0f0f0;
      font-size: 20px;
    }

    .property-group {
      margin-bottom: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #6a11cb;
    }

    .property-group h4 {
      color: #34495e;
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 16px;
    }

    .property-row {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
    }

    .property-label {
      flex: 1;
      color: #555;
      font-size: 14px;
      font-weight: 500;
    }

    .property-value {
      flex: 1;
    }

    input[type="number"],
    input[type="text"],
    input[type="color"],
    select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      transition: border 0.3s;
      box-sizing: border-box;
    }

    input[type="number"]:focus,
    input[type="text"]:focus,
    input[type="color"]:focus,
    select:focus {
      outline: none;
      border-color: #6a11cb;
      box-shadow: 0 0 0 2px rgba(106, 17, 203, 0.2);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
      animation: modalSlideIn 0.3s ease;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-50px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 2px solid #f0f0f0;
    }

    .modal-title {
      font-size: 22px;
      color: #2c3e50;
      font-weight: 600;
      margin: 0;
    }

    .close-modal {
      background: none;
      border: none;
      font-size: 24px;
      color: #7f8c8d;
      cursor: pointer;
      padding: 5px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.3s;
    }

    .close-modal:hover {
      background: #f5f5f5;
      color: #e74c3c;
    }

    .modal-form {
      display: grid;
      gap: 15px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .form-label {
      color: #34495e;
      font-weight: 600;
      font-size: 14px;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 25px;
      justify-content: flex-end;
    }

    .btn {
      padding: 12px 25px;
      border-radius: 8px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 14px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      color: white;
    }

    .btn-secondary {
      background: #95a5a6;
      color: white;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 7px 14px rgba(50, 50, 93, 0.1);
    }

    .instructions {
      background: #e8f4fc;
      border-left: 4px solid #3498db;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
    }

    .instructions h4 {
      color: #2c3e50;
      margin-top: 0;
    }

    .instructions ul {
      margin: 10px 0;
      padding-left: 20px;
      color: #555;
    }

    .instructions li {
      margin-bottom: 5px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>üìê –†–µ–¥–∞–∫—Ç–æ—Ä —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö —á–µ—Ä—Ç–µ–∂–µ–π</h1>
  <p class="subtitle">–°–æ–∑–¥–∞–≤–∞–π—Ç–µ —á–µ—Ä—Ç–µ–∂–∏ —Å –ø—Ä–∏–≤—è–∑–∫–æ–π –∫ —Å–µ—Ç–∫–µ, —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ —Å–≤–æ–π—Å—Ç–≤–∞ –æ–±—ä–µ–∫—Ç–æ–≤ –∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –≤ JSON</p>

  <div class="main-content">
    <div class="left-panel">
      <div id="tools">
        <button onclick="activateLineDrawing()" id="lineDrawingBtn">
          <span>üìè</span> –†–∏—Å–æ–≤–∞—Ç—å –ª–∏–Ω–∏—é
        </button>
        <button onclick="splitLinesAtIntersections()">
          <span>‚úÇÔ∏è</span> –†–∞–∑–±–∏—Ç—å –ª–∏–Ω–∏–∏
        </button>
        <button onclick="findIntersectionsOnly()">
          <span>üîç</span> –ù–∞–π—Ç–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        </button>
        <button onclick="clearIntersectionPoints()">
          <span>üßπ</span> –û—á–∏—Å—Ç–∏—Ç—å –º–∞—Ä–∫–µ—Ä—ã
        </button>
        <button onclick="toggleContinuousMode()" id="continuousModeBtn">
          <span>üîó</span> –ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π —Ä–µ–∂–∏–º (–í–´–ö–õ)
        </button>
        <button onclick="showLinePropertiesModal()">
          <span>‚öôÔ∏è</span> –°–≤–æ–π—Å—Ç–≤–∞ –ª–∏–Ω–∏–∏
        </button>
        <button onclick="saveDrawing()">
          <span>üíæ</span> –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
        </button>
        <button onclick="loadDrawing()">
          <span>üìÇ</span> –ó–∞–≥—Ä—É–∑–∏—Ç—å
        </button>
        <button onclick="clearCanvas()">
          <span>üóëÔ∏è</span> –û—á–∏—Å—Ç–∏—Ç—å
        </button>
        <button onclick="exportToConsole()">
          <span>üìä</span> –≠–∫—Å–ø–æ—Ä—Ç –≤ –∫–æ–Ω—Å–æ–ª—å
        </button>
      </div>

      <div class="properties-panel">
        <h3>–°–≤–æ–π—Å—Ç–≤–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞</h3>
        <div id="props-content">
          <p style="color: #7f8c8d; font-style: italic; text-align: center; padding: 20px;">
            –í—ã–±–µ—Ä–∏—Ç–µ –æ–±—ä–µ–∫—Ç –Ω–∞ —á–µ—Ä—Ç–µ–∂–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–≤–æ–π—Å—Ç–≤
          </p>
        </div>
      </div>

      <div id="status">
        –ì–æ—Ç–æ–≤–æ –∫ —Ä–∞–±–æ—Ç–µ. –û–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ —á–µ—Ä—Ç–µ–∂–µ: 0
      </div>

      <div class="instructions">
        <h4>üìã –ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏:</h4>
        <ul>
          <li><strong>ESC</strong> - –æ—Ç–º–µ–Ω–∞ —Ç–µ–∫—É—â–µ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è</li>
          <li><strong>Delete</strong> - —É–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç</li>
          <li><strong>Ctrl+S</strong> - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —á–µ—Ä—Ç–µ–∂</li>
          <li><strong>Ctrl+O</strong> - –∑–∞–≥—Ä—É–∑–∏—Ç—å —á–µ—Ä—Ç–µ–∂</li>
          <li><strong>Ctrl+Z</strong> - –æ—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ</li>
          <li><strong>Alt + –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ</strong> - –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ö–æ–ª—Å—Ç–∞</li>
          <li><strong>I</strong> - –Ω–∞–π—Ç–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è</li>
          <li><strong>Ctrl+Shift+S</strong> - —Ä–∞–∑–±–∏—Ç—å –ª–∏–Ω–∏–∏</li>
        </ul>
      </div>
    </div>

    <div class="canvas-container">
      <div id="canvas-container">
        <canvas id="fabric-canvas" width="1050" height="600"></canvas>
      </div>
    </div>
  </div>
</div>

<!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–≤–æ–π—Å—Ç–≤ –ª–∏–Ω–∏–∏ -->
<div id="linePropertiesModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 class="modal-title">‚öôÔ∏è –°–≤–æ–π—Å—Ç–≤–∞ –ª–∏–Ω–∏–∏</h2>
      <button class="close-modal" onclick="closeLinePropertiesModal()">√ó</button>
    </div>
    <form id="linePropertiesForm" class="modal-form">
      <div class="form-group">
        <label class="form-label">1. –î–ª–∏–Ω–∞ (L, –º¬≤):</label>
        <input type="number" id="propertyL" step="0.001" min="0" placeholder="0.5237" required>
      </div>
      <div class="form-group">
        <label class="form-label">2. –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç (I):</label>
        <input type="number" id="propertyI" step="0.000001" min="0" placeholder="0.015327" required>
      </div>
      <div class="form-group">
        <label class="form-label">3. –ü–∞—Ä–∞–º–µ—Ç—Ä (K, –º):</label>
        <input type="number" id="propertyK" step="0.001" min="0" placeholder="10.235" required>
      </div>
      <div class="form-group">
        <label class="form-label">4. –í–µ—Å (W, –∫–≥/–º):</label>
        <input type="number" id="propertyW" step="0.01" min="0" placeholder="1.0" required>
      </div>
      <div class="form-group">
        <label class="form-label">5. –ù–∞–∑–≤–∞–Ω–∏–µ –ª–∏–Ω–∏–∏:</label>
        <input type="text" id="propertyName" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –ì–ª–∞–≤–Ω–∞—è –±–∞–ª–∫–∞" required>
      </div>
      <div class="form-group">
        <label class="form-label">–¶–≤–µ—Ç –ª–∏–Ω–∏–∏:</label>
        <input type="color" id="propertyColor" value="#2a9d8f">
      </div>
      <div class="form-group">
        <label class="form-label">–¢–æ–ª—â–∏–Ω–∞ –ª–∏–Ω–∏–∏:</label>
        <select id="propertyWidth">
          <option value="1">1 px</option>
          <option value="2" selected>2 px</option>
          <option value="3">3 px</option>
          <option value="4">4 px</option>
          <option value="5">5 px</option>
        </select>
      </div>
      <div class="modal-buttons">
        <button type="button" class="btn btn-secondary" onclick="closeLinePropertiesModal()">
          –û—Ç–º–µ–Ω–∞
        </button>
        <button type="submit" class="btn btn-primary">
          –ü—Ä–∏–º–µ–Ω–∏—Ç—å —Å–≤–æ–π—Å—Ç–≤–∞
        </button>
      </div>
    </form>
  </div>
</div>

<script>
  // 1. –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –•–û–õ–°–¢–ê
  const canvas = new fabric.Canvas('fabric-canvas', {
    backgroundColor: '#f8f9fa',
    preserveObjectStacking: true,
    selection: true,
    selectionColor: 'rgba(79, 195, 247, 0.3)',
    selectionBorderColor: '#4fc3f7',
    selectionLineWidth: 2
  });

  // 2. –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
  let isDrawingLine = false;
  let isContinuousLineMode = false;
  let lineStartPoint = null;
  let previewLine = null;
  let isDragging = false;
  let lastPosX, lastPosY;
  let lastLineEndPoint = null;
  const SNAP_RADIUS = 15;
  let currentEditingLine = null;

  // 3. –û–¢–†–ò–°–û–í–ö–ê –°–ï–¢–ö–ò
  function drawGrid(gridSize = 20) {
    const width = canvas.width, height = canvas.height;
    const gridLines = [];

    for (let x = 0; x <= width; x += gridSize) {
      gridLines.push(new fabric.Line([x, 0, x, height], {
        stroke: 'rgba(224, 224, 224, 0.7)',
        strokeWidth: 1,
        selectable: false,
        evented: false,
        id: 'grid-line'
      }));
    }

    for (let y = 0; y <= height; y += gridSize) {
      gridLines.push(new fabric.Line([0, y, width, y], {
        stroke: 'rgba(224, 224, 224, 0.7)',
        strokeWidth: 1,
        selectable: false,
        evented: false,
        id: 'grid-line'
      }));
    }

    const gridGroup = new fabric.Group(gridLines, {
      selectable: false,
      evented: false,
      hoverCursor: 'default',
      id: 'grid-group'
    });
    canvas.add(gridGroup);
    canvas.sendToBack(gridGroup);
  }
  drawGrid(20);

  // 4. –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° –ü–ï–†–ï–°–ï–ß–ï–ù–ò–Ø–ú–ò –õ–ò–ù–ò–ô

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –¥–≤—É—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤
  function lineIntersection(line1, line2) {
    // –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ª–∏–Ω–∏–π
    const x1 = line1.x1, y1 = line1.y1;
    const x2 = line1.x2, y2 = line1.y2;
    const x3 = line2.x1, y3 = line2.y1;
    const x4 = line2.x2, y4 = line2.y2;

    // –ï—Å–ª–∏ –ª–∏–Ω–∏–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
    if (line1 === line2) return null;

    // –í—ã—á–∏—Å–ª—è–µ–º –∑–Ω–∞–º–µ–Ω–∞—Ç–µ–ª—å
    const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    // –ï—Å–ª–∏ –ª–∏–Ω–∏–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã –∏–ª–∏ –∫–æ–ª–ª–∏–Ω–µ–∞—Ä–Ω—ã
    if (Math.abs(denominator) < 0.000001) {
      return null;
    }

    // –í—ã—á–∏—Å–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã t –∏ u
    const t = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
    const u = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

    // –ï—Å–ª–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ–±–æ–∏—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤
    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
      // –í—ã—á–∏—Å–ª—è–µ–º —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
      const x = x1 + t * (x2 - x1);
      const y = y1 + t * (y2 - y1);

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–æ—á–∫–∞ –Ω–µ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –∫–æ–Ω—Ü–∞–º –æ—Ç—Ä–µ–∑–∫–æ–≤
      const epsilon = 0.05; // 5% –æ—Ç –¥–ª–∏–Ω—ã –æ—Ç—Ä–µ–∑–∫–∞
      if (t < epsilon || t > 1 - epsilon || u < epsilon || u > 1 - epsilon) {
        return null;
      }

      return {
        x: Math.round(x * 100) / 100,
        y: Math.round(y * 100) / 100,
        t: t,
        line1: line1,
        line2: line2
      };
    }

    return null;
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤—Å–µ—Ö –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –º–µ–∂–¥—É –ª–∏–Ω–∏—è–º–∏
  function findAllIntersections() {
    const lines = canvas.getObjects().filter(obj =>
      obj.type === 'line' && obj.id !== 'grid-line' && obj !== previewLine
    );

    const intersections = [];

    // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º –ø–∞—Ä–∞–º –ª–∏–Ω–∏–π
    for (let i = 0; i < lines.length; i++) {
      for (let j = i + 1; j < lines.length; j++) {
        const intersection = lineIntersection(lines[i], lines[j]);
        if (intersection) {
          intersections.push(intersection);
        }
      }
    }

    return intersections;
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–æ—á–µ–∫ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
  function showIntersectionPoints() {
    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –º–∞—Ä–∫–µ—Ä—ã
    clearIntersectionPoints();

    const intersections = findAllIntersections();

    intersections.forEach((inter, index) => {
      // –°–æ–∑–¥–∞–µ–º –∫—Ä—É–≥ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
      const circle = new fabric.Circle({
        left: inter.x - 8,
        top: inter.y - 8,
        radius: 8,
        fill: '#e74c3c',
        stroke: '#c0392b',
        strokeWidth: 2,
        selectable: false,
        hasControls: false,
        hasBorders: false,
        evented: false,
        originX: 'center',
        originY: 'center',
        id: 'intersection-point'
      });

      // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç —Å –Ω–æ–º–µ—Ä–æ–º
      const text = new fabric.Text((index + 1).toString(), {
        left: inter.x + 12,
        top: inter.y - 12,
        fontSize: 14,
        fill: '#2c3e50',
        fontWeight: 'bold',
        selectable: false,
        evented: false,
        id: 'intersection-point',
        textBackgroundColor: 'rgba(255, 255, 255, 0.8)',
        padding: 3
      });

      canvas.add(circle);
      canvas.add(text);
      canvas.sendToBack(circle);
      canvas.sendToBack(text);
    });

    canvas.renderAll();
    return intersections;
  }

  // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è –ª–∏–Ω–∏–π
  function splitLinesAtIntersections() {
    console.log("–ù–∞—á–∏–Ω–∞—é –ø–æ–∏—Å–∫ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è –ª–∏–Ω–∏–π...");

    // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
    const intersections = findAllIntersections();

    if (intersections.length === 0) {
      document.getElementById('status').innerHTML = '–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.';
      return;
    }

    console.log(`–ù–∞–π–¥–µ–Ω–æ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π: ${intersections.length}`);

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
    showIntersectionPoints();

    // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ —Ä–∞–∑–±–∏—Ç—å
    const linesToSplit = new Map();

    intersections.forEach(inter => {
      // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –∫ –ø–µ—Ä–≤–æ–π –ª–∏–Ω–∏–∏
      if (!linesToSplit.has(inter.line1)) {
        linesToSplit.set(inter.line1, []);
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–∞–∫–∞—è —Ç–æ—á–∫–∞ –µ—â–µ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞
      const existingPoint = linesToSplit.get(inter.line1).find(p =>
        Math.abs(p.x - inter.x) < 1 && Math.abs(p.y - inter.y) < 1
      );

      if (!existingPoint) {
        linesToSplit.get(inter.line1).push({x: inter.x, y: inter.y, t: inter.t});
      }

      // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –∫–æ –≤—Ç–æ—Ä–æ–π –ª–∏–Ω–∏–∏
      if (!linesToSplit.has(inter.line2)) {
        linesToSplit.set(inter.line2, []);
      }

      const existingPoint2 = linesToSplit.get(inter.line2).find(p =>
        Math.abs(p.x - inter.x) < 1 && Math.abs(p.y - inter.y) < 1
      );

      if (!existingPoint2) {
        linesToSplit.get(inter.line2).push({x: inter.x, y: inter.y, t: inter.t});
      }
    });

    console.log(`–õ–∏–Ω–∏–π –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è: ${linesToSplit.size}`);

    // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –¥–ª—è –Ω–æ–≤—ã—Ö –ª–∏–Ω–∏–π
    const newLines = [];

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é –ª–∏–Ω–∏—é
    linesToSplit.forEach((points, line) => {
      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –∏ –∫–æ–Ω–µ—á–Ω—É—é —Ç–æ—á–∫–∏
      const startPoint = {
        x: line.x1,
        y: line.y1,
        t: 0
      };
      const endPoint = {
        x: line.x2,
        y: line.y2,
        t: 1
      };

      // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —Ç–æ—á–∫–∏ (–Ω–∞—á–∞–ª–æ, –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è, –∫–æ–Ω–µ—Ü)
      const allPoints = [startPoint, ...points, endPoint];

      // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ç–æ—á–∫–∏ –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä—É t
      allPoints.sort((a, b) => a.t - b.t);

      console.log(`–õ–∏–Ω–∏—è –∏–º–µ–µ—Ç ${allPoints.length} —Ç–æ—á–µ–∫ –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è`);

      // –°–æ–∑–¥–∞–µ–º —Å–µ–≥–º–µ–Ω—Ç—ã –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏
      for (let i = 0; i < allPoints.length - 1; i++) {
        const p1 = allPoints[i];
        const p2 = allPoints[i + 1];

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É —Å–µ–≥–º–µ–Ω—Ç–∞ (–º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ - 2px)
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const length = Math.sqrt(dx * dx + dy * dy);

        if (length > 2) {
          // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç –¥–ª–∏–Ω—ã –¥–ª—è —Å–≤–æ–π—Å—Ç–≤
          const totalLength = Math.sqrt(
            Math.pow(line.x2 - line.x1, 2) +
            Math.pow(line.y2 - line.y1, 2)
          );
          const lengthRatio = length / totalLength;

          // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Å–µ–≥–º–µ–Ω—Ç
          const segment = new fabric.Line([
            p1.x, p1.y,
            p2.x, p2.y
          ], {
            stroke: line.stroke || '#2a9d8f',
            strokeWidth: line.strokeWidth || 3,
            strokeDashArray: line.strokeDashArray,
            fill: false,
            strokeLineCap: 'round',
            hasControls: true,
            hasBorders: true,
            lockRotation: false,
            selectable: true,
            properties: line.properties ? {
              name: `${line.properties.name || '–õ–∏–Ω–∏—è'} (—Å–µ–≥–º–µ–Ω—Ç ${i+1})`,
              L: line.properties.L ? line.properties.L * lengthRatio : 0.5 * lengthRatio,
              I: line.properties.I ? line.properties.I * lengthRatio : 0.015 * lengthRatio,
              K: line.properties.K ? line.properties.K * lengthRatio : 10 * lengthRatio,
              W: line.properties.W ? line.properties.W * lengthRatio : 1.0 * lengthRatio,
              length: length
            } : {
              name: `–°–µ–≥–º–µ–Ω—Ç ${i+1}`,
              L: 0.5 * lengthRatio,
              I: 0.015 * lengthRatio,
              K: 10 * lengthRatio,
              W: 1.0 * lengthRatio,
              length: length
            }
          });

          newLines.push(segment);
        }
      }
    });

    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –ª–∏–Ω–∏–∏ –∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ
    linesToSplit.forEach((points, line) => {
      canvas.remove(line);
    });

    newLines.forEach(segment => {
      canvas.add(segment);
    });

    // –£–±–∏—Ä–∞–µ–º –º–∞—Ä–∫–µ—Ä—ã –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –ø–æ—Å–ª–µ —Ä–∞–∑–±–∏–µ–Ω–∏—è
    clearIntersectionPoints();

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
    document.getElementById('status').innerHTML =
      `–†–∞–∑–±–∏—Ç–æ ${linesToSplit.size} –ª–∏–Ω–∏–π –Ω–∞ ${newLines.length} —Å–µ–≥–º–µ–Ω—Ç–æ–≤. –ù–∞–π–¥–µ–Ω–æ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π: ${intersections.length}`;

    canvas.renderAll();
    updatePropertiesPanel();
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –º–∞—Ä–∫–µ—Ä–æ–≤ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
  function clearIntersectionPoints() {
    const objects = canvas.getObjects();
    for (let i = objects.length - 1; i >= 0; i--) {
      if (objects[i].id === 'intersection-point') {
        canvas.remove(objects[i]);
      }
    }
    canvas.renderAll();
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –±–µ–∑ —Ä–∞–∑–±–∏–µ–Ω–∏—è
  function findIntersectionsOnly() {
    clearIntersectionPoints();
    const intersections = showIntersectionPoints();

    if (intersections.length === 0) {
      document.getElementById('status').innerHTML = '–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.';
    } else {
      document.getElementById('status').innerHTML =
        `–ù–∞–π–¥–µ–Ω–æ ${intersections.length} –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π. –¢–æ—á–∫–∏ –æ—Ç–º–µ—á–µ–Ω—ã –∫—Ä–∞—Å–Ω—ã–º–∏ –∫—Ä—É–≥–∞–º–∏.`;
    }

    return intersections;
  }

  // 5. –ò–ù–°–¢–†–£–ú–ï–ù–¢ –†–ò–°–û–í–ê–ù–ò–Ø –õ–ò–ù–ò–ô
  function activateLineDrawing() {
    deactivateAllModes();
    isDrawingLine = true;
    canvas.defaultCursor = 'crosshair';
    canvas.selection = false;
    canvas.forEachObject(obj => obj.selectable = false);

    document.getElementById('lineDrawingBtn').classList.add('active-mode');

    let modeText = '–†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ª–∏–Ω–∏–∏: –∫–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –Ω–∞—á–∞–ª–∞, –∑–∞—Ç–µ–º –¥–ª—è –∫–æ–Ω—Ü–∞.';
    if (isContinuousLineMode) {
      modeText += ' –†–µ–∂–∏–º –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–≥–æ —Ä–∏—Å–æ–≤–∞–Ω–∏—è –í–ö–õ–Æ–ß–ï–ù.';
    }
    document.getElementById('status').innerHTML = modeText + ' ESC –¥–ª—è –æ—Ç–º–µ–Ω—ã.';
  }

  // 6. –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–ï –ù–ï–ü–†–ï–†–´–í–ù–û–ì–û –†–ï–ñ–ò–ú–ê
  function toggleContinuousMode() {
    isContinuousLineMode = !isContinuousLineMode;
    const btn = document.getElementById('continuousModeBtn');
    if (isContinuousLineMode) {
      btn.innerHTML = '<span>üîó</span> –ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π —Ä–µ–∂–∏–º (–í–ö–õ)';
      btn.style.background = 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)';
      document.getElementById('status').innerHTML =
        '–ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π —Ä–µ–∂–∏–º –í–ö–õ–Æ–ß–ï–ù. –ù–æ–≤—ã–µ –ª–∏–Ω–∏–∏ –±—É–¥—É—Ç –ø—Ä–∏–≤—è–∑—ã–≤–∞—Ç—å—Å—è –∫ –∫–æ–Ω—Ü—É –ø—Ä–µ–¥—ã–¥—É—â–µ–π.';
    } else {
      btn.innerHTML = '<span>üîó</span> –ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π —Ä–µ–∂–∏–º (–í–´–ö–õ)';
      btn.style.background = 'linear-gradient(135deg, #6a11cb 0%, #2575fc 100%)';
      document.getElementById('status').innerHTML =
        '–ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π —Ä–µ–∂–∏–º –í–´–ö–õ–Æ–ß–ï–ù.';
    }
  }

  // 7. –î–ï–ê–ö–¢–ò–í–ê–¶–ò–Ø –í–°–ï–• –†–ï–ñ–ò–ú–û–í
  function deactivateAllModes() {
    if (isDrawingLine) {
      isDrawingLine = false;
      document.getElementById('lineDrawingBtn').classList.remove('active-mode');
      if (previewLine) {
        canvas.remove(previewLine);
        previewLine = null;
      }
      lineStartPoint = null;
    }

    canvas.defaultCursor = 'default';
    canvas.selection = true;
    canvas.forEachObject(obj => {
      if (obj.id !== 'grid-group') {
        obj.selectable = true;
      }
    });

    updateStatus();
  }

  // 8. –§–£–ù–ö–¶–ò–ò –ü–†–ò–í–Ø–ó–ö–ò –ö –°–ï–¢–ö–ï
  function snapToGrid(value, gridSize = 20) {
    return Math.round(value / gridSize) * gridSize;
  }

  // 9. –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô –ú–´–®–ò
  canvas.on('mouse:down', function(options) {
    const pointer = canvas.getPointer(options.e);
    const gridSize = 20;

    if (isDrawingLine) {
      let snappedX, snappedY;

      if (isContinuousLineMode && lastLineEndPoint) {
        const distanceToLastPoint = Math.sqrt(
          Math.pow(pointer.x - lastLineEndPoint.x, 2) +
          Math.pow(pointer.y - lastLineEndPoint.y, 2)
        );

        if (distanceToLastPoint < SNAP_RADIUS) {
          snappedX = lastLineEndPoint.x;
          snappedY = lastLineEndPoint.y;
        } else {
          snappedX = snapToGrid(pointer.x, gridSize);
          snappedY = snapToGrid(pointer.y, gridSize);
        }
      } else {
        snappedX = snapToGrid(pointer.x, gridSize);
        snappedY = snapToGrid(pointer.y, gridSize);
      }

      if (!lineStartPoint) {
        lineStartPoint = { x: snappedX, y: snappedY };

        previewLine = new fabric.Line([
          lineStartPoint.x, lineStartPoint.y,
          snappedX, snappedY
        ], {
          stroke: '#2a9d8f',
          strokeWidth: 3,
          strokeDashArray: [5, 5],
          selectable: false,
          evented: false
        });
        canvas.add(previewLine);

        document.getElementById('status').innerHTML =
          `–ù–∞—á–∞–ª–æ –ª–∏–Ω–∏–∏: ${lineStartPoint.x},${lineStartPoint.y}px ‚Üí –ø–µ—Ä–µ–º–µ—â–∞–π—Ç–µ –º—ã—à—å. –ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –∫–æ–Ω—Ü–∞.`;
      } else {
        const length = Math.sqrt(
          Math.pow(snappedX - lineStartPoint.x, 2) +
          Math.pow(snappedY - lineStartPoint.y, 2)
        );

        const finalLine = new fabric.Line([
          lineStartPoint.x, lineStartPoint.y,
          snappedX, snappedY
        ], {
          stroke: '#2a9d8f',
          strokeWidth: 3,
          fill: false,
          strokeLineCap: 'round',
          hasControls: true,
          hasBorders: true,
          lockRotation: false,
          properties: {
            name: '–õ–∏–Ω–∏—è ' + (canvas.getObjects().filter(o => o.type === 'line' && o.id !== 'grid-line').length + 1),
            L: 0.5,
            I: 0.015,
            K: 10,
            W: 1.0,
            length: length
          }
        });

        canvas.add(finalLine);
        canvas.setActiveObject(finalLine);
        updatePropertiesPanel();

        lastLineEndPoint = { x: snappedX, y: snappedY };

        if (isContinuousLineMode) {
          lineStartPoint = { x: snappedX, y: snappedY };
          previewLine.set({
            x1: lineStartPoint.x,
            y1: lineStartPoint.y,
            x2: snappedX,
            y2: snappedY
          });

          document.getElementById('status').innerHTML =
            `–õ–∏–Ω–∏—è —Å–æ–∑–¥–∞–Ω–∞. –ù–∞—á–∞–ª–æ –Ω–æ–≤–æ–π –ª–∏–Ω–∏–∏: ${lineStartPoint.x},${lineStartPoint.y}px`;
        } else {
          deactivateAllModes();
        }
      }
      return;
    }

    if (options.e.altKey || options.e.spaceKey) {
      isDragging = true;
      lastPosX = pointer.x;
      lastPosY = pointer.y;
      canvas.defaultCursor = 'grabbing';
      return;
    }
  });

  canvas.on('mouse:move', function(options) {
    const pointer = canvas.getPointer(options.e);
    const gridSize = 20;

    let snappedX, snappedY;
    if (isDrawingLine) {
      snappedX = snapToGrid(pointer.x, gridSize);
      snappedY = snapToGrid(pointer.y, gridSize);
    } else {
      snappedX = pointer.x;
      snappedY = pointer.y;
    }

    updateStatus(snappedX, snappedY, isDrawingLine);

    if (isDrawingLine && lineStartPoint && previewLine) {
      previewLine.set({ x2: snappedX, y2: snappedY });
      previewLine.setCoords();
      canvas.requestRenderAll();

      const dx = snappedX - lineStartPoint.x;
      const dy = snappedY - lineStartPoint.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.round(Math.atan2(dy, dx) * 180 / Math.PI);

      let statusAddition = ` | –î–ª–∏–Ω–∞: ${Math.round(length)}px | –£–≥–æ–ª: ${angle}¬∞`;

      if (isContinuousLineMode && lastLineEndPoint) {
        const distanceToLast = Math.sqrt(
          Math.pow(pointer.x - lastLineEndPoint.x, 2) +
          Math.pow(pointer.y - lastLineEndPoint.y, 2)
        );

        if (distanceToLast < SNAP_RADIUS) {
          statusAddition += ' | üìç –ü—Ä–∏–≤—è–∑–∫–∞ –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –ª–∏–Ω–∏–∏';
        }
      }

      document.getElementById('status').innerHTML += statusAddition;
    }

    if (isDragging && (options.e.altKey || options.e.spaceKey)) {
      const deltaX = pointer.x - lastPosX;
      const deltaY = pointer.y - lastPosY;

      canvas.relativePan(new fabric.Point(deltaX, deltaY));
      lastPosX = pointer.x;
      lastPosY = pointer.y;
    }
  });

  canvas.on('mouse:up', function() {
    if (isDragging) {
      isDragging = false;
      canvas.defaultCursor = 'default';
    }
  });

  // 10. –ü–†–ò–í–Ø–ó–ö–ê –û–ë–™–ï–ö–¢–û–í –ö –°–ï–¢–ö–ï
  canvas.on('object:moving', function(options) {
    const obj = options.target;
    const gridSize = 20;

    obj.set({
      left: snapToGrid(obj.left, gridSize),
      top: snapToGrid(obj.top, gridSize)
    });
    obj.setCoords();
  });

  canvas.on('object:scaling', function(options) {
    const obj = options.target;
    const gridSize = 20;

    if (obj.type === 'line') {
      const newX2 = snapToGrid(obj.x2 * obj.scaleX, gridSize);
      const newY2 = snapToGrid(obj.y2 * obj.scaleY, gridSize);
      obj.set({
        x2: newX2,
        y2: newY2,
        scaleX: 1,
        scaleY: 1
      });

      if (obj.properties) {
        const length = Math.sqrt(
          Math.pow(newX2 - obj.x1, 2) +
          Math.pow(newY2 - obj.y1, 2)
        );
        obj.properties.length = length;
      }
    }
    obj.setCoords();
  });

  // 11. –í–´–ë–û–† –û–ë–™–ï–ö–¢–ê –ò –û–ë–ù–û–í–õ–ï–ù–ò–ï –ü–ê–ù–ï–õ–ò –°–í–û–ô–°–¢–í
  canvas.on('selection:created', function() {
    updatePropertiesPanel();
  });

  canvas.on('selection:updated', function() {
    updatePropertiesPanel();
  });

  canvas.on('selection:cleared', function() {
    updatePropertiesPanel();
  });

  // 12. –ú–û–î–ê–õ–¨–ù–û–ï –û–ö–ù–û –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–Ø –°–í–û–ô–°–¢–í –õ–ò–ù–ò–ò
  function showLinePropertiesModal() {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'line') {
      alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –ª–∏–Ω–∏—é –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–≤–æ–π—Å—Ç–≤.');
      return;
    }

    currentEditingLine = activeObject;
    const props = activeObject.properties || {
      name: '–õ–∏–Ω–∏—è',
      L: 0.5,
      I: 0.015,
      K: 10,
      W: 1.0,
      length: 0
    };

    document.getElementById('propertyL').value = props.L;
    document.getElementById('propertyI').value = props.I;
    document.getElementById('propertyK').value = props.K;
    document.getElementById('propertyW').value = props.W;
    document.getElementById('propertyName').value = props.name;
    document.getElementById('propertyColor').value = activeObject.stroke || '#2a9d8f';
    document.getElementById('propertyWidth').value = activeObject.strokeWidth || 2;

    document.getElementById('linePropertiesModal').style.display = 'flex';
  }

  function closeLinePropertiesModal() {
    document.getElementById('linePropertiesModal').style.display = 'none';
    currentEditingLine = null;
  }

  document.getElementById('linePropertiesForm').onsubmit = function(e) {
    e.preventDefault();

    if (!currentEditingLine) return false;

    const newProperties = {
      name: document.getElementById('propertyName').value,
      L: parseFloat(document.getElementById('propertyL').value),
      I: parseFloat(document.getElementById('propertyI').value),
      K: parseFloat(document.getElementById('propertyK').value),
      W: parseFloat(document.getElementById('propertyW').value),
      length: currentEditingLine.properties?.length ||
        Math.sqrt(
          Math.pow(currentEditingLine.x2 - currentEditingLine.x1, 2) +
          Math.pow(currentEditingLine.y2 - currentEditingLine.y1, 2)
        )
    };

    currentEditingLine.set({
      stroke: document.getElementById('propertyColor').value,
      strokeWidth: parseInt(document.getElementById('propertyWidth').value),
      properties: newProperties
    });

    canvas.renderAll();
    updatePropertiesPanel();
    closeLinePropertiesModal();

    console.log('–û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –ª–∏–Ω–∏–∏:', newProperties);
    return false;
  };

  // 13. –û–ë–ù–û–í–õ–ï–ù–ò–ï –ü–ê–ù–ï–õ–ò –°–í–û–ô–°–¢–í
  function updatePropertiesPanel() {
    const activeObj = canvas.getActiveObject();
    const propsContent = document.getElementById('props-content');

    if (!activeObj) {
      propsContent.innerHTML = `
                    <p style="color: #7f8c8d; font-style: italic; text-align: center; padding: 20px;">
                        –í—ã–±–µ—Ä–∏—Ç–µ –æ–±—ä–µ–∫—Ç –Ω–∞ —á–µ—Ä—Ç–µ–∂–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–≤–æ–π—Å—Ç–≤
                    </p>
                `;
      return;
    }

    let content = `
                <div class="property-group">
                    <h4>üìÑ –û—Å–Ω–æ–≤–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞</h4>
                    <div class="property-row">
                        <div class="property-label">–¢–∏–ø:</div>
                        <div class="property-value"><strong>${activeObj.type}</strong></div>
                    </div>
                    <div class="property-row">
                        <div class="property-label">–ü–æ–∑–∏—Ü–∏—è X:</div>
                        <div class="property-value">${Math.round(activeObj.left || activeObj.x1 || 0)}px</div>
                    </div>
                    <div class="property-row">
                        <div class="property-label">–ü–æ–∑–∏—Ü–∏—è Y:</div>
                        <div class="property-value">${Math.round(activeObj.top || activeObj.y1 || 0)}px</div>
                    </div>
            `;

    if (activeObj.type === 'line') {
      const length = Math.sqrt(
        Math.pow(activeObj.x2 - activeObj.x1, 2) +
        Math.pow(activeObj.y2 - activeObj.y1, 2)
      );
      content += `
                    <div class="property-row">
                        <div class="property-label">–î–ª–∏–Ω–∞:</div>
                        <div class="property-value">${Math.round(length)}px</div>
                    </div>
                `;

      if (activeObj.properties) {
        content += `
                        <div class="property-group" style="border-left-color: #2a9d8f;">
                            <h4>üìä –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</h4>
                            <div class="property-row">
                                <div class="property-label">–ù–∞–∑–≤–∞–Ω–∏–µ:</div>
                                <div class="property-value">${activeObj.properties.name}</div>
                            </div>
                            <div class="property-row">
                                <div class="property-label">L (–º¬≤):</div>
                                <div class="property-value">${activeObj.properties.L.toFixed(4)}</div>
                            </div>
                            <div class="property-row">
                                <div class="property-label">I:</div>
                                <div class="property-value">${activeObj.properties.I.toFixed(6)}</div>
                            </div>
                            <div class="property-row">
                                <div class="property-label">K (–º):</div>
                                <div class="property-value">${activeObj.properties.K.toFixed(3)}</div>
                            </div>
                            <div class="property-row">
                                <div class="property-label">W (–∫–≥/–º):</div>
                                <div class="property-value">${activeObj.properties.W.toFixed(2)}</div>
                            </div>
                        </div>
                    `;
      }
    }

    content += `
                <div style="margin-top: 15px; text-align: center;">
                    <button onclick="showLinePropertiesModal()"
                            ${activeObj.type !== 'line' ? 'disabled style="opacity: 0.5;"' : ''}
                            style="padding: 8px 16px; font-size: 13px;">
                        ${activeObj.type === 'line' ? '‚öôÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã' : '–¢–æ–ª—å–∫–æ –¥–ª—è –ª–∏–Ω–∏–π'}
                    </button>
                </div>
            `;

    propsContent.innerHTML = content;
  }

  // 14. –ì–û–†–Ø–ß–ò–ï –ö–õ–ê–í–ò–®–ò
  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
      if (isContinuousLineMode && isDrawingLine) {
        lineStartPoint = lastLineEndPoint ? { ...lastLineEndPoint } : null;
        if (previewLine && lineStartPoint) {
          previewLine.set({
            x1: lineStartPoint.x,
            y1: lineStartPoint.y,
            x2: lineStartPoint.x,
            y2: lineStartPoint.y
          });
          document.getElementById('status').innerHTML =
            '–¢–µ–∫—É—â–∞—è –ª–∏–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏.';
        }
      } else {
        deactivateAllModes();
        document.getElementById('status').innerHTML = '–†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω.';
      }
    }

    if (event.key === 'Delete' || event.key === 'Backspace') {
      const activeObject = canvas.getActiveObject();
      if (activeObject && activeObject.id !== 'grid-group') {
        canvas.remove(activeObject);
        updateStatus();
        updatePropertiesPanel();
      }
    }

    if (event.ctrlKey && event.key === 's') {
      event.preventDefault();
      saveDrawing();
    }

    if (event.ctrlKey && event.shiftKey && event.key === 'S') {
      event.preventDefault();
      splitLinesAtIntersections();
    }

    if (event.ctrlKey && event.key === 'o') {
      event.preventDefault();
      loadDrawing();
    }

    if (event.key === 'i' || event.key === 'I') {
      event.preventDefault();
      findIntersectionsOnly();
    }

    if (event.ctrlKey && event.key === 'z') {
      event.preventDefault();
      const objects = canvas.getObjects().filter(obj => obj.id !== 'grid-group');
      if (objects.length > 0) {
        const lastObj = objects[objects.length - 1];
        if (lastObj.type === 'line') {
          const lines = objects.filter(obj => obj.type === 'line' && obj.id !== 'grid-line');
          if (lines.length > 1) {
            const prevLine = lines[lines.length - 2];
            lastLineEndPoint = { x: prevLine.x2, y: prevLine.y2 };
          } else {
            lastLineEndPoint = null;
          }
        }
        canvas.remove(lastObj);
        updateStatus();
        updatePropertiesPanel();
      }
    }

    if (event.key === 'c' || event.key === 'C') {
      event.preventDefault();
      toggleContinuousMode();
    }

    if (event.key === 'p' || event.key === 'P') {
      event.preventDefault();
      showLinePropertiesModal();
    }
  });

  // 15. –≠–ö–°–ü–û–†–¢ –í –ö–û–ù–°–û–õ–¨
  function exportToConsole() {
    const objects = canvas.getObjects().filter(obj => obj.id !== 'grid-group' && obj.id !== 'grid-line');
    const exportData = {
      timestamp: new Date().toISOString(),
      totalObjects: objects.length,
      objects: []
    };

    objects.forEach((obj, index) => {
      const objData = {
        id: index + 1,
        type: obj.type,
        position: {
          x: obj.left || obj.x1,
          y: obj.top || obj.y1
        },
        properties: obj.properties || {}
      };

      if (obj.type === 'line') {
        objData.dimensions = {
          x1: obj.x1,
          y1: obj.y1,
          x2: obj.x2,
          y2: obj.y2,
          length: Math.sqrt(Math.pow(obj.x2 - obj.x1, 2) + Math.pow(obj.y2 - obj.y1, 2))
        };
      }

      exportData.objects.push(objData);
    });

    console.log('üìä –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä—Ç–µ–∂–∞:', exportData);
    console.table(exportData.objects.map(obj => ({
      'ID': obj.id,
      '–¢–∏–ø': obj.type,
      'X': Math.round(obj.position.x),
      'Y': Math.round(obj.position.y),
      '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã': obj.properties.name || '–ù–µ—Ç'
    })));

    document.getElementById('status').innerHTML =
      `–î–∞–Ω–Ω—ã–µ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ –∫–æ–Ω—Å–æ–ª—å. –í—Å–µ–≥–æ –æ–±—ä–µ–∫—Ç–æ–≤: ${objects.length}`;
  }

  // 16. –°–û–•–†–ê–ù–ï–ù–ò–ï –ò –ó–ê–ì–†–£–ó–ö–ê
  function saveDrawing() {
    const json = JSON.stringify(canvas.toJSON(['id', 'properties']));
    localStorage.setItem('fabricDrawing', json);

    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `—á–µ—Ä—Ç–µ–∂-${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    document.getElementById('status').innerHTML =
      `‚úÖ –ß–µ—Ä—Ç–µ–∂ —Å–æ—Ö—Ä–∞–Ω–µ–Ω! (${canvas.getObjects().filter(obj => obj.id !== 'grid-group' && obj.id !== 'grid-line').length} –æ–±—ä–µ–∫—Ç–æ–≤)`;
  }

  function loadDrawing() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';

    input.onchange = function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const json = event.target.result;
          deactivateAllModes();
          canvas.clear();
          drawGrid(20);
          canvas.loadFromJSON(json, function() {
            const lines = canvas.getObjects().filter(obj =>
              obj.type === 'line' && obj.id !== 'grid-line'
            );

            if (lines.length > 0) {
              const lastLine = lines[lines.length - 1];
              lastLineEndPoint = { x: lastLine.x2, y: lastLine.y2 };
            }

            canvas.renderAll();
            updateStatus();
            updatePropertiesPanel();
            document.getElementById('status').innerHTML += ' | –ß–µ—Ä—Ç–µ–∂ –∑–∞–≥—Ä—É–∂–µ–Ω.';

            console.log('–ó–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä—Ç–µ–∂ —Å–æ —Å–≤–æ–π—Å—Ç–≤–∞–º–∏ –æ–±—ä–µ–∫—Ç–æ–≤:');
            canvas.getObjects().forEach((obj, i) => {
              if (obj.id !== 'grid-group' && obj.properties) {
                console.log(`–û–±—ä–µ–∫—Ç ${i + 1}:`, obj.properties);
              }
            });
          });
        } catch (error) {
          alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: ' + error.message);
        }
      };
      reader.readAsText(file);
    };

    input.click();
  }

  function clearCanvas() {
    if (confirm('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã —Å —á–µ—Ä—Ç–µ–∂–∞?')) {
      deactivateAllModes();
      lastLineEndPoint = null;
      canvas.getObjects().forEach(obj => {
        if (obj.id !== 'grid-group') {
          canvas.remove(obj);
        }
      });
      canvas.renderAll();
      updateStatus();
      updatePropertiesPanel();
    }
  }

  // 17. –û–ë–ù–û–í–õ–ï–ù–ò–ï –°–¢–ê–¢–£–°–ê
  function updateStatus(x, y, isDrawing = false) {
    const count = canvas.getObjects().filter(obj =>
      obj.id !== 'grid-group' && obj.id !== 'grid-line'
    ).length;
    const activeObj = canvas.getActiveObject();
    let statusText = `<strong>–û–±—ä–µ–∫—Ç–æ–≤:</strong> ${count}`;

    if (x !== undefined && y !== undefined) {
      statusText += ` | <strong>–ö—É—Ä—Å–æ—Ä:</strong> ${Math.round(x)}, ${Math.round(y)}px`;
    }

    if (activeObj) {
      statusText += ` | <strong>–í—ã–±—Ä–∞–Ω:</strong> ${activeObj.type}`;
    }

    if (isContinuousLineMode) {
      statusText += ' | üîó <strong>–ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π —Ä–µ–∂–∏–º</strong>';
    }

    if (!isDrawing) {
      document.getElementById('status').innerHTML = statusText;
    }
  }

  // 18. –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
  document.addEventListener('DOMContentLoaded', function() {
    updatePropertiesPanel();
    updateStatus();

    console.log('üöÄ –†–µ–¥–∞–∫—Ç–æ—Ä —á–µ—Ä—Ç–µ–∂–µ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω!');
    console.log('–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏: ESC, Delete, Ctrl+S, Ctrl+O, Ctrl+Z, C, P, I, Ctrl+Shift+S');
  });

  window.addEventListener('resize', function() {
    canvas.setDimensions({
      width: Math.min(1000, window.innerWidth - 100),
      height: Math.min(600, window.innerHeight - 200)
    });
    canvas.renderAll();
  });
</script>
</body>
</html>